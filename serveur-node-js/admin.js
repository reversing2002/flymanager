const express = require('express');
const { createClient } = require('@supabase/supabase-js');
const router = express.Router();

// Cr√©ation du client Supabase admin
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Variables d\'environnement Supabase manquantes');
  process.exit(1);
}

const adminClient = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// Middleware de v√©rification admin
const checkAdminRole = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: 'Non autoris√©' });
  }

  try {
    const token = authHeader.split(' ')[1];
    const { data: { user }, error } = await adminClient.auth.getUser(token);
    
    if (error) {
      console.error('‚ùå Erreur auth.getUser:', error);
      return res.status(401).json({ error: 'Non autoris√©' });
    }
    
    if (!user) {
      console.error('‚ùå Utilisateur non trouv√©');
      return res.status(401).json({ error: 'Non autoris√©' });
    }

    // V√©rifier si l'utilisateur est admin via user_group_memberships
    const { data: groups, error: groupsError } = await adminClient
      .from('user_group_memberships')
      .select(`
        user_groups (
          code
        )
      `)
      .eq('user_id', user.id);

    if (groupsError) {
      console.error('‚ùå Erreur r√©cup√©ration groupes:', groupsError);
      return res.status(500).json({ error: 'Erreur serveur' });
    }

    const isAdmin = groups?.some(membership => membership.user_groups?.code === 'ADMIN');
    if (!isAdmin) {
      console.error('‚ùå Utilisateur non admin:', user.id);
      return res.status(403).json({ error: 'Acc√®s refus√©' });
    }

    req.user = user;
    next();
  } catch (error) {
    console.error('‚ùå Erreur middleware admin:', error);
    return res.status(500).json({ error: 'Erreur serveur' });
  }
};

// Liste des utilisateurs
router.get('/users', checkAdminRole, async (req, res) => {
  try {
    const { clubId } = req.query;
    
    if (!clubId) {
      return res.status(400).json({ error: 'Club ID requis' });
    }

    console.log('üìã R√©cup√©ration des utilisateurs pour le club:', clubId);
    
    // R√©cup√©rer les membres du club
    const { data: members, error: membersError } = await adminClient
      .from('club_members')
      .select('user_id')
      .eq('club_id', clubId)
      .eq('status', 'ACTIVE');

    if (membersError) {
      console.error('‚ùå Erreur r√©cup√©ration membres:', membersError);
      return res.status(500).json({ error: membersError.message });
    }

    if (!members || members.length === 0) {
      console.log('‚ÑπÔ∏è Aucun membre trouv√© pour ce club');
      return res.json({ data: [] });
    }

    // R√©cup√©rer les informations des utilisateurs
    const userIds = members.map(member => member.user_id);
    const { data: users, error: usersError } = await adminClient
      .from('users')
      .select('*')
      .in('id', userIds);

    if (usersError) {
      console.error('‚ùå Erreur r√©cup√©ration utilisateurs:', usersError);
      return res.status(500).json({ error: usersError.message });
    }

    console.log('‚úÖ Utilisateurs r√©cup√©r√©s:', users.length);
    res.json({ data: users });
  } catch (error) {
    console.error('‚ùå Erreur inattendue:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des utilisateurs' });
  }
});

// R√©cup√©rer un utilisateur par email
router.get('/users/by-email/:email', checkAdminRole, async (req, res) => {
  try {
    const { email } = req.params;
    console.log('üîç Recherche utilisateur par email:', email);
    
    const { data, error } = await adminClient
      .from('users')
      .select('*')
      .eq('email', email)
      .single();

    if (error) {
      console.error('‚ùå Utilisateur non trouv√©:', error);
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    console.log('‚úÖ Utilisateur trouv√©:', data.id);
    res.json({ data });
  } catch (error) {
    console.error('‚ùå Erreur inattendue:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration de l\'utilisateur' });
  }
});

// V√©rifier l'utilisateur auth
router.get('/users/:userId/auth', checkAdminRole, async (req, res) => {
  try {
    const { userId } = req.params;
    console.log('üîç V√©rification auth pour utilisateur:', userId);
    
    const { data, error } = await adminClient
      .from('users')
      .select('auth_id')
      .eq('id', userId)
      .single();

    if (error || !data?.auth_id) {
      console.error('‚ùå Auth ID non trouv√©:', error);
      return res.status(404).json({ error: 'Utilisateur auth non trouv√©' });
    }

    const { data: authUser, error: authError } = await adminClient.auth.admin.getUserById(data.auth_id);

    if (authError) {
      console.error('‚ùå Utilisateur auth non trouv√©:', authError);
      return res.status(404).json({ error: 'Utilisateur auth non trouv√©' });
    }

    console.log('‚úÖ Utilisateur auth trouv√©:', authUser.id);
    res.json({ data: authUser });
  } catch (error) {
    console.error('‚ùå Erreur inattendue:', error);
    res.status(500).json({ error: 'Erreur lors de la v√©rification de l\'utilisateur auth' });
  }
});

// Suppression d'un utilisateur
router.delete('/users/:userId', checkAdminRole, async (req, res) => {
  try {
    const { userId } = req.params;
    console.log('üóëÔ∏è Suppression utilisateur:', userId);
    
    // R√©cup√©rer l'auth_id
    const { data: user, error: userError } = await adminClient
      .from('users')
      .select('auth_id')
      .eq('id', userId)
      .single();

    if (userError) {
      console.error('‚ùå Utilisateur non trouv√©:', userError);
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    // Supprimer l'utilisateur auth s'il existe
    if (user.auth_id) {
      console.log('üóëÔ∏è Suppression utilisateur auth:', user.auth_id);
      const { error: authError } = await adminClient.auth.admin.deleteUser(user.auth_id);
      if (authError) {
        console.error('‚ùå Erreur suppression auth:', authError);
        return res.status(400).json({ error: authError.message });
      }
    }

    // Supprimer l'utilisateur de la base de donn√©es
    const { error: dbError } = await adminClient
      .from('users')
      .delete()
      .eq('id', userId);

    if (dbError) {
      console.error('‚ùå Erreur suppression DB:', dbError);
      return res.status(400).json({ error: dbError.message });
    }
    
    console.log('‚úÖ Utilisateur supprim√© avec succ√®s');
    res.json({ success: true });
  } catch (error) {
    console.error('‚ùå Erreur inattendue:', error);
    res.status(500).json({ error: 'Erreur lors de la suppression de l\'utilisateur' });
  }
});

// Cr√©ation d'un utilisateur
router.post('/users', checkAdminRole, async (req, res) => {
  try {
    const { email, password, userData, roles, clubId } = req.body;
    console.log('‚ûï Cr√©ation/Rattachement utilisateur:', email);

    // V√©rifier si l'email existe d√©j√†
    const { data: existingUser, error: userError } = await adminClient
      .from('users')
      .select('id, email')
      .eq('email', email)
      .single();

    if (userError && userError.code !== 'PGRST116') { // PGRST116 = not found
      console.error('‚ùå Erreur v√©rification utilisateur:', userError);
      return res.status(500).json({ error: userError.message });
    }

    let userId;

    if (existingUser) {
      console.log('‚ÑπÔ∏è Utilisateur existant trouv√©:', existingUser.id);
      userId = existingUser.id;

      // V√©rifier si l'utilisateur est d√©j√† membre du club
      const { data: existingMembership, error: membershipError } = await adminClient
        .from('club_members')
        .select('*')
        .eq('user_id', userId)
        .eq('club_id', clubId)
        .single();

      if (membershipError && membershipError.code !== 'PGRST116') {
        console.error('‚ùå Erreur v√©rification membership:', membershipError);
        return res.status(500).json({ error: membershipError.message });
      }

      if (existingMembership) {
        console.error('‚ùå L\'utilisateur est d√©j√† membre de ce club');
        return res.status(400).json({ error: 'L\'utilisateur est d√©j√† membre de ce club' });
      }

      // Ajouter l'utilisateur au club
      const { error: addMemberError } = await adminClient
        .from('club_members')
        .insert([{
          user_id: userId,
          club_id: clubId,
          status: 'ACTIVE'
        }]);

      if (addMemberError) {
        console.error('‚ùå Erreur ajout au club:', addMemberError);
        return res.status(400).json({ error: addMemberError.message });
      }

      console.log('‚úÖ Utilisateur rattach√© au club avec succ√®s');
      return res.json({ 
        success: true, 
        user: existingUser,
        message: 'Utilisateur rattach√© au club avec succ√®s'
      });

    } else {
      // G√©n√©rer un login unique √† partir de l'email
      let login = email.split('@')[0];
      let increment = 0;
      let loginExists = true;
      
      // Boucle pour trouver un login unique
      while (loginExists) {
        const loginToTry = increment === 0 ? login : `${login}${increment}`;
        const { data: existingLogin } = await adminClient
          .from('users')
          .select('login')
          .eq('login', loginToTry)
          .single();
        
        if (!existingLogin) {
          login = loginToTry;
          loginExists = false;
        } else {
          increment++;
        }
      }

      console.log('üîë Login g√©n√©r√©:', login);

      // Cr√©er l'utilisateur dans la base de donn√©es
      const { data: newUser, error: createError } = await adminClient
        .from('users')
        .insert([{
          email,
          login,
          first_name: userData.first_name || login,
          last_name: userData.last_name || '',
          phone: userData.phone
        }])
        .select()
        .single();

      if (createError) {
        console.error('‚ùå Erreur cr√©ation utilisateur:', createError);
        return res.status(400).json({ error: createError.message });
      }

      userId = newUser.id;

      // Cr√©er l'utilisateur auth avec le m√™me ID
      const { error: authError } = await adminClient.rpc('create_auth_user', {
        p_user_id: userId,
        p_email: email,
        p_password: password,
        p_login: login,
        p_role: 'authenticated',
        p_user_metadata: {
          db_id: userId,
          first_name: userData.first_name,
          last_name: userData.last_name
        }
      });

      if (authError) {
        console.error('‚ùå Erreur cr√©ation auth:', authError);
        // Nettoyer l'utilisateur cr√©√© si l'auth √©choue
        await adminClient.from('users').delete().eq('id', userId);
        return res.status(400).json({ error: authError.message });
      }

      // Ajouter l'utilisateur au club
      const { error: addMemberError } = await adminClient
        .from('club_members')
        .insert([{
          user_id: userId,
          club_id: clubId,
          status: 'ACTIVE'
        }]);

      if (addMemberError) {
        console.error('‚ùå Erreur ajout au club:', addMemberError);
        // Nettoyer l'utilisateur cr√©√© si l'ajout au club √©choue
        await adminClient.from('users').delete().eq('id', userId);
        return res.status(400).json({ error: addMemberError.message });
      }

      // Ajouter les r√¥les
      if (roles && roles.length > 0) {
        const { error: rolesError } = await adminClient
          .from('user_group_memberships')
          .insert(
            roles.map(role => ({
              user_id: userId,
              user_group_id: role
            }))
          );

        if (rolesError) {
          console.error('‚ùå Erreur ajout r√¥les:', rolesError);
          // Ne pas nettoyer l'utilisateur ici car c'est moins critique
        }
      }

      console.log('‚úÖ Utilisateur cr√©√© avec succ√®s');
      return res.json({ success: true, user: newUser });
    }
  } catch (error) {
    console.error('‚ùå Erreur inattendue:', error);
    res.status(500).json({ error: 'Erreur lors de la cr√©ation de l\'utilisateur' });
  }
});

// Mise √† jour d'un utilisateur
router.put('/users/:userId', checkAdminRole, async (req, res) => {
  try {
    const { userId } = req.params;
    const userData = req.body;
    console.log('‚úèÔ∏è Mise √† jour utilisateur:', userId);
    console.log('üìù Donn√©es re√ßues:', JSON.stringify(userData, null, 2));

    // V√©rifier d'abord si l'utilisateur existe
    const { data: existingUser, error: fetchError } = await adminClient
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();

    if (fetchError) {
      console.error('‚ùå Erreur lors de la recherche de l\'utilisateur:', fetchError);
      return res.status(404).json({ error: 'Erreur lors de la recherche de l\'utilisateur' });
    }

    if (!existingUser) {
      console.error('‚ùå Utilisateur non trouv√©:', userId);
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    console.log('‚úÖ Utilisateur trouv√©:', existingUser.id);

    // Extraire le mot de passe des donn√©es avant la mise √† jour de la table users
    const { password, ...userDataWithoutPassword } = userData;
    console.log('üîê Mot de passe extrait:', password ? 'Pr√©sent' : 'Absent');
    console.log('üìù Donn√©es √† mettre √† jour:', JSON.stringify(userDataWithoutPassword, null, 2));

    let updatedUser = existingUser;

    // Ne mettre √† jour la table users que s'il y a des donn√©es √† mettre √† jour
    if (Object.keys(userDataWithoutPassword).length > 0) {
      // Mettre √† jour l'utilisateur dans la base de donn√©es
      const { data: updates, error: updateError } = await adminClient
        .from('users')
        .update(userDataWithoutPassword)
        .eq('id', userId)
        .select();

      if (updateError) {
        console.error('‚ùå Erreur mise √† jour utilisateur:', updateError);
        return res.status(400).json({ error: updateError.message });
      }

      console.log('üìä R√©sultat de la mise √† jour:', updates ? `${updates.length} lignes modifi√©es` : '0 ligne modifi√©e');

      if (!updates || updates.length === 0) {
        console.error('‚ùå Aucune mise √† jour effectu√©e');
        console.log('üí° √âtat actuel:', JSON.stringify(existingUser, null, 2));
        console.log('üí° Tentative de mise √† jour avec:', JSON.stringify(userDataWithoutPassword, null, 2));
        return res.status(400).json({ error: 'Aucune mise √† jour effectu√©e' });
      }

      updatedUser = updates[0];
      console.log('‚úÖ Donn√©es mises √† jour:', JSON.stringify(updatedUser, null, 2));
    } else {
      console.log('‚ÑπÔ∏è Pas de mise √† jour de la table users n√©cessaire');
    }

    // Si l'email ou le mot de passe a chang√©, mettre √† jour dans auth
    if (userData.email || password) {
      if (userData.email) {
        console.log('‚úèÔ∏è Mise √† jour email auth:', userData.email);
        const { error: emailError } = await adminClient
          .rpc('update_user_email', { 
            p_user_id: userId,
            p_email: userData.email
          });

        if (emailError) {
          console.error('‚ùå Erreur mise √† jour email:', emailError);
          return res.status(400).json({ error: emailError.message });
        }
        console.log('‚úÖ Email mis √† jour avec succ√®s');
      }
      
      if (password) {
        console.log('‚úèÔ∏è Mise √† jour mot de passe via RPC');
        const { data: passwordData, error: passwordError } = await adminClient
          .rpc('update_auth_user', {
            p_email: existingUser.email,
            p_password: password,
            p_user_metadata: null
          });

        if (passwordError) {
          console.error('‚ùå Erreur mise √† jour mot de passe:', passwordError);
          return res.status(400).json({ error: passwordError.message });
        }
        console.log('‚úÖ Mot de passe mis √† jour avec succ√®s');
      }
    }

    console.log('‚úÖ Utilisateur mis √† jour avec succ√®s');
    res.json({ user: updatedUser });
  } catch (error) {
    console.error('‚ùå Erreur inattendue:', error);
    res.status(500).json({ error: 'Erreur lors de la mise √† jour de l\'utilisateur' });
  }
});

module.exports = router;
